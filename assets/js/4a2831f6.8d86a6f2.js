"use strict";(self.webpackChunkonboard_d_docs=self.webpackChunkonboard_d_docs||[]).push([[96],{1169:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>p,frontMatter:()=>l,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"technical-notes","title":"Hackathon notes","description":"Why choosing Langchain JS Over Teams AI library for LLM Orchestration?","source":"@site/docs/4-technical-notes.mdx","sourceDirName":".","slug":"/technical-notes","permalink":"/m365-ai-agents-hackathon-onboard_D/technical-notes","draft":false,"unlisted":false,"editUrl":"https://github.com/FranckyC/m365-ai-agents-hackathon-onboard_D/docs/4-technical-notes.mdx","tags":[],"version":"current","lastUpdatedBy":"Franck Cornu","lastUpdatedAt":1745974567000,"sidebarPosition":4,"frontMatter":{},"sidebar":"mainSidebar","previous":{"title":"Minimal path to awesome","permalink":"/m365-ai-agents-hackathon-onboard_D/agent-testing"}}');var a=n(4848),o=n(8453);const i=n.p+"assets/images/all_tasks_ui-e29b43039d8b7bb918cfb67577b664b0.png",r=n.p+"assets/images/task_detail_ui-cfd752b7a3abbd72f73ebc15e4a2614b.png",l={},c="Hackathon notes",d={},h=[{value:"Why choosing Langchain JS Over Teams AI library for LLM Orchestration?",id:"why-choosing-langchain-js-over-teams-ai-library-for-llm-orchestration",level:2},{value:"Why choosing &#39;botbuilder&#39; (Bot Framework V4) over the new &#39;@microsoft/agents-hosting&#39; SDK (Microsoft 365 Agents SDK)?",id:"why-choosing-botbuilder-bot-framework-v4-over-the-new-microsoftagents-hosting-sdk-microsoft-365-agents-sdk",level:2},{value:"What challenges did we face?",id:"what-challenges-did-we-face",level:2},{value:"Handling different JSON tool outputs with LLM and adaptive cards",id:"handling-different-json-tool-outputs-with-llm-and-adaptive-cards",level:3},{value:"Supporting both application/delegated permissions on LLM tools seamlessly",id:"supporting-both-applicationdelegated-permissions-on-llm-tools-seamlessly",level:3},{value:"Handling &#39;Human-in-the-loop&#39; pattern with regular bot dialogs",id:"handling-human-in-the-loop-pattern-with-regular-bot-dialogs",level:3},{value:"What is left?",id:"what-is-left",level:2}];function u(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"hackathon-notes",children:"Hackathon notes"})}),"\n",(0,a.jsx)(t.h2,{id:"why-choosing-langchain-js-over-teams-ai-library-for-llm-orchestration",children:"Why choosing Langchain JS Over Teams AI library for LLM Orchestration?"}),"\n",(0,a.jsx)(t.p,{children:"We found Langchain to be more user-friendly and closely aligned with core LLM concepts compared to the Teams AI library, particularly in terms of tools management. Additionally, Langchain's documentation is superior, offering clear usage examples. The only drawback is that integrating Langchain with Bot Framework features to build an end-to-end chat solution requires more effort."}),"\n",(0,a.jsx)(t.h2,{id:"why-choosing-botbuilder-bot-framework-v4-over-the-new-microsoftagents-hosting-sdk-microsoft-365-agents-sdk",children:"Why choosing 'botbuilder' (Bot Framework V4) over the new '@microsoft/agents-hosting' SDK (Microsoft 365 Agents SDK)?"}),"\n",(0,a.jsx)(t.p,{children:"We initially started building our solution using the new Microsoft 365 Agents JavaScript SDK. However, we quickly realized it wasn't the best option for us due to several limitations:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Lack of parity with the traditional Bot Framework"}),": The SDK didn't allow us to easily achieve our goals, such as proactive notifications and conversation flows. We spent too much time figuring out how to accomplish tasks that were straightforward with the Bot Framework. Unfortunately, there is no migration guide available yet to assist with the transition. Given these challenges, we decided to stick with the familiar territory for time reasons."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"No tooling"}),": The Microsoft Agents 365 SDK is not integrated with the Teams Toolkit, making it harder to develop solutions quickly."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Too much confusion between Teams AI library/Microsoft 365 Agents SDK/Bot Framework"}),': Online, you\'ll find numerous "agents" samples using various technology stacks (e.g., ',(0,a.jsx)(t.a,{href:"https://github.com/microsoft/Agents/blob/main/samples",children:"M365 Agents SDK samples"}),", ",(0,a.jsx)(t.a,{href:"https://github.com/microsoft/teams-ai/tree/main/js/samples",children:"Teams AI library samples"}),", ",(0,a.jsx)(t.a,{href:"https://github.com/microsoft/BotBuilder-Samples/tree/main/samples",children:"Bot Framework samples"}),"). This can be very misleading for developers, as it creates confusion about which technology to use. In reality, developers often end up mixing concepts from all these samples."]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Ultimately, we concluded that the Microsoft 365 Agents SDK was not ready yet for the purpose of this hackathon."}),"\n",(0,a.jsx)(t.h2,{id:"what-challenges-did-we-face",children:"What challenges did we face?"}),"\n",(0,a.jsx)(t.p,{children:"During the development, we actually faced many challenges!"}),"\n",(0,a.jsx)(t.h3,{id:"handling-different-json-tool-outputs-with-llm-and-adaptive-cards",children:"Handling different JSON tool outputs with LLM and adaptive cards"}),"\n",(0,a.jsx)(t.p,{children:"In the solution, actions requested by the user generate different UI outputs from the agent (sometimes just text, sometimes adaptive cards with heteregonous JSON formats). The challenge was to adapt these different outputs returned by LLM/tools to the correct UI in Teams:"}),"\n",(0,a.jsxs)("div",{className:"flex justify-center space-x-4",children:[(0,a.jsxs)("div",{className:"flex flex-col items-center",children:[(0,a.jsx)("p",{className:"font-bold",children:"Adaptive cards for list of assigned tasks"}),(0,a.jsx)("img",{className:"",src:i})]}),(0,a.jsxs)("div",{className:"flex flex-col items-center",children:[(0,a.jsx)("p",{className:"font-bold",children:"Adaptive cards for task details"}),(0,a.jsx)("img",{className:"",src:r})]})]}),"\n",(0,a.jsx)("br",{}),"\n",(0,a.jsxs)(t.p,{children:["Because the data format was dynamic, we couldn't use a structured output for all the LLM answers (using either Langchain ",(0,a.jsx)(t.a,{href:"https://python.langchain.com/docs/concepts/structured_outputs/",children:"structured outputs"})," or OpenAI ",(0,a.jsx)(t.a,{href:"https://platform.openai.com/docs/guides/structured-outputs",children:(0,a.jsx)(t.code,{children:"json_schema"})}),"). For direct 1:1 mapping (tool output->adaptive card), we used the ",(0,a.jsx)(t.a,{href:"https://js.langchain.com/docs/how_to/tool_artifacts/",children:"'artifact'"})," feature of Langchain to map the data returned by tools directly to adaptive cards. Letting the LLM figure out the JSON format to pass to the card was not efficient and not reliable. Here is an example how we manage tools JSON outputs:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-json",children:"// Tool output\nexport const getUserTasks = tool(\n  async (args: any, config: RunnableConfig) => {\n   \n    tasks = await plannerService.getPlanTasks(planId);\n    ...\n    return [\n      `Successfully retrieved array of ${tasks.length} tasks ${JSON.stringify(tasks.map(t => { return { id: t.id, title: t.title, references: t.references, dueDateTime: t.dueDateTime }}))} assigned to the user.`, // Returned to the LLM\n      tasks // Artifact\n    ];\n  },\n...\n\n// Usage in adaptive card\ncase AgentTools.GetTasksForUsers:\n    card = AdaptiveCards.declare<any>(NotificationMessageAdaptiveCard).render({ answer: llmResponseContent, data: llmResponse.messages[lastIndex].artifact});\n...\n"})}),"\n",(0,a.jsxs)(t.p,{children:["For responses requiring multiple tools to be invoked sequentially (e.g., retrieving task details involves using two tools: ",(0,a.jsx)(t.code,{children:"GetTaskDetails"})," to obtain task attributes like title, due date, etc., and ",(0,a.jsx)(t.code,{children:"SearchReferenceContent"})," to locate content from referenced documents in the search index, culminating in a comprehensive summary that incorporates all the gathered information), rather than directing the model to generate a JSON output, we introduced an additional tool, ",(0,a.jsx)(t.code,{children:"GetTaskStructuredOutput"}),", to format the data from the previously invoked tools into a structured output."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-json",children:'export const getTaskStructuredOutput = tool(\n\n    async (args: { task: any}) => {\n  \n      return [\n        "Task formatted successufly", \n        args.task\n      ]\n    },\n    {\n      name: AgentTools.GetTaskStructuredOutput,\n      description: \'Format a task as structured output\',      \n      responseFormat: "content_and_artifact",\n      schema: z.object({\n        task: z.object({\n          title: z.string().describe(`title extract from the task`).nullable(),\n          summary: z.string().describe(`generated summary of what user needs to do according to task description extract and retieved content from references if available. Text only, no markdown`).nullable(),\n          priority: z.number().describe(`priority extract from the task data`).nullable(),\n          startDateTime: z.string().describe(`start date extract from the task data`).nullable(),\n          dueDateTime: z.string().describe(`due date extract from the task data`).nullable(),\n          deepLink: z.string().describe(`link extract from the task data`).nullable()\n        }).nullable()\n      }).describe("the task details")\n    }\n  )\n'})}),"\n",(0,a.jsx)(t.p,{children:"This tool establishes a clear schema outlining the expected data and returns it in its original form, ensuring it can be safely used as an artifact. We discovered that this method was significantly more efficient than having the LLM generate a JSON output. The truly challenging aspect, which required multiple attempts, was getting the LLM to utilize the final tool to format the output correctly. Here is the prompt we use to ensure the desired tool is employed:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:'...\n## CAPABILITY: Get details about a specific task ##\n  - Examples: \n      - Give me more information about the "..." task.\n      - What is the task ..\n      - Waht should i do for task #5\n  - If not provided, you **must** ask for task ID. Otherwise, lookup the task id in your chat history or use the one provided by user before using tool.\n  - If a task has references, retrieve associated content passing all URLs at once and summarize the content to clearly explain what about the task is.\n  - Finally format the task as structured output using <GetTaskStructuredOutput> before answering.\n..\n'})}),"\n",(0,a.jsx)(t.h3,{id:"supporting-both-applicationdelegated-permissions-on-llm-tools-seamlessly",children:"Supporting both application/delegated permissions on LLM tools seamlessly"}),"\n",(0,a.jsx)(t.p,{children:"Because of the nature of the solution having both proactive notifications and direct interactions with the agent, we needed to support both delegated and application access. Even if we could have use application permissions everywhere for convenient reasons, we wanted to create a secure solution handling bot type of permissions keeping it transparent for tools:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.em,{children:"Delegated permissions"}),": actions are performed on-behalf of the user when he interacts directly with the agent."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.em,{children:"Application permissions"}),": actions are performed by the agent itself without any user interactions for proactive notifications."]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["For this, we used the ",(0,a.jsx)(t.a,{href:"https://js.langchain.com/docs/concepts/tools#runnableconfig",children:(0,a.jsx)(t.code,{children:"RunnableConfig"})})," feature of Langchain pass parameters to tools using the following code:"]}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsx)(t.li,{children:"Instanciate a Microsoft Graph client like this:"}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-json",children:"// Delegated permissions \nconst oboCredential = new OnBehalfOfUserCredential(tokenResponse.ssoToken, oboAuthConfig);\nconst authProvider = new TokenCredentialAuthenticationProvider(\n  oboCredential,\n  {\n\t  scopes: [MicrosoftGraphScopes.TasksReadWrite, MicrosoftGraphScopes.SiteReadAll],\n  }\n);\n...\n\n// Application permissions\nconst appCredential = new AppCredential(appAuthConfig);           \nconst authProvider = new TokenCredentialAuthenticationProvider(appCredential, {\n\tscopes: [MicrosoftGraphScopes.Default],\n});\n...\n"})}),"\n",(0,a.jsxs)(t.ol,{start:"2",children:["\n",(0,a.jsx)(t.li,{children:"Pass the provider to the tools when invoking the LLM:"}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-json",children:"// Pass the provider to tools\nconst runnableConfig = {\n\t...\n\tauthProvider: authProvider,\n};\n\nconst llmResponse = await this.agent.invoke(\n  { messages: messages },\n  { configurable: runnableConfig}\n);\n\n...\n"})}),"\n",(0,a.jsxs)(t.ol,{start:"3",children:["\n",(0,a.jsx)(t.li,{children:"Finally use it in tools:"}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-json",children:"export const getUserTasks = tool(\n  async (args: any, config: RunnableConfig) => {\n   \n    let tasks: IPlannerTask[] = [];\n\n    // Initialize Graph client instance with authProvider (can be app or delegated permissions her depending on the caller)\n    const graphClient = Client.initWithMiddleware({ authProvider: config.configurable.authProvider });\n    const plannerService = new PlannerService(graphClient);\n\n    ...\n    tasks = await plannerService.getPlanTasks(planId);\n    \n    ...\n"})}),"\n",(0,a.jsx)(t.h3,{id:"handling-human-in-the-loop-pattern-with-regular-bot-dialogs",children:"Handling 'Human-in-the-loop' pattern with regular bot dialogs"}),"\n",(0,a.jsx)(t.p,{children:'As previously mentioned, Langchain is completely agnostic to "chat implementation technology," allowing you to develop your own user interface on top of it. In our case, we utilize the Bot Framework for that aspect, incorporating bot dialogs to manage this scenario through dialog branches. If tools are chosen by the LLM, prior to execution, we ensure any tools requiring human confirmation are identified and addressed. This process is carried out as follows:'}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-json",children:'// Create a Langchain agent with prebuilt StateGraph\nconst aiAgent = createReactAgent({\n  llm: agentModel,\n  tools: agentTools,\n  checkpointSaver: agentCheckpointer,\n  interruptBefore: ["tools"] // Human-in-the-loop: will stop the LLM after tools selection, letting you decide what to do\n});\n...\n'})}),"\n",(0,a.jsx)(t.p,{children:"Tool validation in the main agent dialog:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-json",children:"// Agent dialog\n\nconst llmResponse = await this.agent.invoke(\n          { messages: messages },\n          { configurable: runnableConfig}\n      );\n\n// Check invoked tools\nconst toolCalls = llmResponse.messages[llmResponse.messages.length-1].tool_calls\n\n// Data to be passed across dialogs\nconst modelData = {\n    ...\n    toolCalls: toolCalls\n} as IAgentStepData;\n\nfor (const selectedTool of toolCalls) {\n    // Determine which tool needs a human in the loop and an explicit confirmation to be executed\n    switch (selectedTool?.name) {\n\n        case 'UpdateTaskCompletion':\n            return await stepContext.beginDialog(HUMAN_IN_THE_LOOP_DIALOG, modelData);\n\n        default:\n        break;\n    }\n}\n"})}),"\n",(0,a.jsx)(t.h2,{id:"what-is-left",children:"What is left?"}),"\n",(0,a.jsx)(t.p,{children:"Regrettably, we were unable to implement all the features we initially envisioned for this agent. Some of the missed features include:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Token Management System"}),": A mechanism to monitor token usage and optimize costs associated with AI service consumption."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Debugging Agent Outputs"}),": A user-specific debug mode integrated into adaptive card responses, enabling the debugging of LLM reasoning and reviewing decisions made by the agent directly from its answers."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Responsible AI Practices"}),": Enhancements to refine prompts and establish safeguards to ensure the agent operates effectively within the scope of its intended objectives."]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"That will be for the next time!"})]})}function p(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>r});var s=n(6540);const a={},o=s.createContext(a);function i(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);